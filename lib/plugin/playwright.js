'use strict';

const fs = require('fs');
const net = require('net');
const os = require('os');
const path = require('path');
const { spawn, spawnSync } = require('child_process');

const EXTENSIONS = [
    ['ublock-origin-lite', 'ddkjiahejlhfcafbddmgiahcphecmpfh'],
    ['adguard', 'bgnkhhnnamicmpeenaelnjfhikgbkllg'],
    ['privacy-badger', 'pkehgijcmpdhfbdbbnkijodmdjhbjlgp'],
    ['webrtc-leak-shield', 'bppamachkoflopbagkdoflbgfjflfnfl'],
    ['webgl-fingerprint-defender', 'olnbjpaejebpnokblkepbphhembdicik']
];

const SCENE_ORDER = ['cont-headless', 'cont-headed', 'host-headless', 'host-headed'];

const SCENE_DEFS = {
    'cont-headless': {
        type: 'container',
        configFile: 'container-headless.json',
        composeFile: 'compose-headless.yaml',
        projectName: 'my-playwright-cont-headless',
        containerName: 'my-playwright-cont-headless',
        portKey: 'contHeadless',
        headless: true,
        listenHost: '0.0.0.0'
    },
    'cont-headed': {
        type: 'container',
        configFile: 'container-headed.json',
        composeFile: 'compose-headed.yaml',
        projectName: 'my-playwright-cont-headed',
        containerName: 'my-playwright-cont-headed',
        portKey: 'contHeaded',
        headless: false,
        listenHost: '0.0.0.0'
    },
    'host-headless': {
        type: 'host',
        configFile: 'host-headless.json',
        portKey: 'hostHeadless',
        headless: true,
        listenHost: '127.0.0.1'
    },
    'host-headed': {
        type: 'host',
        configFile: 'host-headed.json',
        portKey: 'hostHeaded',
        headless: false,
        listenHost: '127.0.0.1'
    }
};

const VALID_RUNTIME = new Set(['container', 'host', 'mixed']);
const VALID_ACTIONS = new Set(['up', 'down', 'status', 'health', 'logs']);
const CONTAINER_EXTENSION_ROOT = '/app/extensions';

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function tailText(filePath, lineCount) {
    if (!fs.existsSync(filePath)) {
        return '';
    }
    const lines = fs.readFileSync(filePath, 'utf8').split(/\r?\n/);
    return lines.slice(-lineCount).join('\n');
}

function asObject(value) {
    if (!value || typeof value !== 'object' || Array.isArray(value)) {
        return {};
    }
    return value;
}

function asStringArray(value, fallback) {
    if (!Array.isArray(value)) {
        return fallback;
    }
    return value
        .map(item => String(item || '').trim())
        .filter(Boolean);
}

function isHostPermission(value) {
    if (value === '<all_urls>') {
        return true;
    }
    return /^(?:\*|http|https|file|ftp):\/\//.test(value);
}

function scriptSourcesFromHtml(htmlFile) {
    const content = fs.readFileSync(htmlFile, { encoding: 'utf8' });
    const scripts = [...content.matchAll(/<script[^>]+src=["']([^"']+)["']/gi)].map(m => m[1]);
    return scripts.filter(src => !/^(?:https?:)?\/\//.test(src));
}

function convertManifestV2ToV3(extDir) {
    const manifestFile = path.join(extDir, 'manifest.json');
    const manifest = JSON.parse(fs.readFileSync(manifestFile, 'utf8'));
    if (manifest.manifest_version !== 2) {
        return false;
    }

    manifest.manifest_version = 3;

    if (manifest.browser_action && !manifest.action) {
        manifest.action = manifest.browser_action;
        delete manifest.browser_action;
    }
    if (manifest.page_action && !manifest.action) {
        manifest.action = manifest.page_action;
        delete manifest.page_action;
    }

    const background = manifest.background;
    if (background && typeof background === 'object' && !Array.isArray(background)) {
        let scripts = [];
        if (Array.isArray(background.scripts)) {
            scripts = background.scripts.filter(s => typeof s === 'string');
        } else if (typeof background.page === 'string') {
            const pagePath = path.join(extDir, background.page);
            if (fs.existsSync(pagePath)) {
                scripts = scriptSourcesFromHtml(pagePath);
            }
        }

        if (scripts.length > 0) {
            const swName = 'generated_background_sw.js';
            const swFile = path.join(extDir, swName);
            const swLines = [
                '// Auto-generated by manyoyo playwright ext-download for MV3.',
                `importScripts(${scripts.map(s => JSON.stringify(s)).join(', ')});`,
                ''
            ];
            fs.writeFileSync(swFile, swLines.join('\n'), 'utf8');
            manifest.background = { service_worker: swName };
        } else {
            delete manifest.background;
        }
    }

    if (typeof manifest.content_security_policy === 'string') {
        manifest.content_security_policy = { extension_pages: manifest.content_security_policy };
    }

    if (Array.isArray(manifest.permissions)) {
        const hostPermissions = Array.isArray(manifest.host_permissions) ? [...manifest.host_permissions] : [];
        const keptPermissions = [];

        for (const perm of manifest.permissions) {
            if (typeof perm === 'string' && isHostPermission(perm)) {
                if (!hostPermissions.includes(perm)) {
                    hostPermissions.push(perm);
                }
            } else {
                keptPermissions.push(perm);
            }
        }

        manifest.permissions = keptPermissions;
        if (hostPermissions.length > 0) {
            manifest.host_permissions = hostPermissions;
        }
    }

    const war = manifest.web_accessible_resources;
    if (Array.isArray(war) && war.length > 0 && war.every(v => typeof v === 'string')) {
        manifest.web_accessible_resources = [
            {
                resources: war,
                matches: ['<all_urls>']
            }
        ];
    }

    fs.writeFileSync(manifestFile, `${JSON.stringify(manifest, null, 2)}\n`, 'utf8');
    return true;
}

function buildCrxUrl(extId, prodversion) {
    return (
        'https://clients2.google.com/service/update2/crx' +
        `?response=redirect&prodversion=${prodversion}` +
        '&acceptformat=crx2,crx3' +
        `&x=id%3D${extId}%26installsource%3Dondemand%26uc`
    );
}

function crxZipOffset(data) {
    if (data.subarray(0, 4).toString('ascii') !== 'Cr24') {
        throw new Error('not a CRX file');
    }

    const version = data.readUInt32LE(4);
    if (version === 2) {
        const pubLen = data.readUInt32LE(8);
        const sigLen = data.readUInt32LE(12);
        return 16 + pubLen + sigLen;
    }
    if (version === 3) {
        const headerLen = data.readUInt32LE(8);
        return 12 + headerLen;
    }
    throw new Error(`unsupported CRX version: ${version}`);
}

class PlaywrightPlugin {
    constructor(options = {}) {
        this.projectRoot = options.projectRoot || path.join(__dirname, '..', '..');
        this.stdout = options.stdout || process.stdout;
        this.stderr = options.stderr || process.stderr;
        this.globalConfig = asObject(options.globalConfig);
        this.runConfig = asObject(options.runConfig);
        this.config = this.resolveConfig();
    }

    resolveConfig() {
        const homeDir = os.homedir();
        const pluginRootDir = path.join(homeDir, '.manyoyo', 'plugin', 'playwright');
        const defaultConfig = {
            runtime: 'mixed',
            enabledScenes: [...SCENE_ORDER],
            hostListen: '127.0.0.1',
            mcpDefaultHost: 'host.docker.internal',
            dockerTag: process.env.PLAYWRIGHT_MCP_DOCKER_TAG || 'latest',
            npmVersion: process.env.PLAYWRIGHT_MCP_NPM_VERSION || 'latest',
            containerRuntime: 'podman',
            vncPasswordEnvKey: 'VNC_PASSWORD',
            headedImage: 'localhost/xcanwin/manyoyo-playwright-headed',
            configDir: path.join(pluginRootDir, 'config'),
            runDir: path.join(pluginRootDir, 'run'),
            extensionProdversion: '132.0.0.0',
            composeDir: path.join(__dirname, 'playwright-assets'),
            ports: {
                contHeadless: 8931,
                contHeaded: 8932,
                hostHeadless: 8933,
                hostHeaded: 8934,
                contHeadedNoVnc: 6080
            }
        };

        const merged = {
            ...defaultConfig,
            ...this.globalConfig,
            ...this.runConfig,
            ports: {
                ...defaultConfig.ports,
                ...asObject(this.globalConfig.ports),
                ...asObject(this.runConfig.ports)
            }
        };

        merged.runtime = String(merged.runtime || defaultConfig.runtime).trim().toLowerCase();
        if (!VALID_RUNTIME.has(merged.runtime)) {
            throw new Error(`playwright.runtime 无效: ${merged.runtime}`);
        }

        merged.enabledScenes = asStringArray(
            this.runConfig.enabledScenes,
            asStringArray(this.globalConfig.enabledScenes, [...defaultConfig.enabledScenes])
        );

        if (merged.enabledScenes.length === 0) {
            throw new Error('playwright.enabledScenes 不能为空');
        }

        const invalidScene = merged.enabledScenes.find(scene => !SCENE_DEFS[scene]);
        if (invalidScene) {
            throw new Error(`playwright.enabledScenes 包含未知场景: ${invalidScene}`);
        }

        return merged;
    }

    writeStdout(line = '') {
        this.stdout.write(`${line}\n`);
    }

    writeStderr(line = '') {
        this.stderr.write(`${line}\n`);
    }

    runCmd(args, { env = null, captureOutput = false, check = true } = {}) {
        const result = spawnSync(args[0], args.slice(1), {
            encoding: 'utf8',
            env: env || process.env,
            stdio: captureOutput ? ['ignore', 'pipe', 'pipe'] : 'inherit'
        });

        const completed = {
            returncode: result.status === null ? 1 : result.status,
            stdout: typeof result.stdout === 'string' ? result.stdout : '',
            stderr: typeof result.stderr === 'string' ? result.stderr : ''
        };

        if (result.error) {
            if (check) {
                throw result.error;
            }
            completed.returncode = 1;
            return completed;
        }

        if (check && completed.returncode !== 0) {
            const error = new Error(`command failed with exit code ${completed.returncode}`);
            error.returncode = completed.returncode;
            error.stdout = completed.stdout;
            error.stderr = completed.stderr;
            throw error;
        }

        return completed;
    }

    ensureCommandAvailable(command) {
        const name = String(command || '').trim();
        if (!/^[A-Za-z0-9._-]+$/.test(name)) {
            return false;
        }
        const result = spawnSync('sh', ['-c', `command -v ${name}`], {
            encoding: 'utf8',
            stdio: ['ignore', 'ignore', 'ignore']
        });
        return result.status === 0;
    }

    scenePort(sceneName) {
        const def = SCENE_DEFS[sceneName];
        return Number(this.config.ports[def.portKey]);
    }

    sceneConfigPath(sceneName) {
        const def = SCENE_DEFS[sceneName];
        return path.join(this.config.configDir, def.configFile);
    }

    scenePidFile(sceneName) {
        return path.join(this.config.runDir, `${sceneName}.pid`);
    }

    sceneLogFile(sceneName) {
        return path.join(this.config.runDir, `${sceneName}.log`);
    }

    extensionDirPath() {
        return path.join(os.homedir(), '.manyoyo', 'plugin', 'playwright', 'extensions');
    }

    extensionTmpDirPath() {
        return path.join(os.homedir(), '.manyoyo', 'plugin', 'playwright', 'tmp-crx');
    }

    resolveTargets(sceneName = 'all') {
        const requested = String(sceneName || 'all').trim();
        const enabledSet = new Set(this.config.enabledScenes);
        const runtime = this.config.runtime;

        const isAllowedByRuntime = (scene) => {
            const type = SCENE_DEFS[scene].type;
            if (runtime === 'mixed') {
                return true;
            }
            return runtime === type;
        };

        if (requested !== 'all') {
            if (!SCENE_DEFS[requested]) {
                throw new Error(`未知场景: ${requested}`);
            }
            if (!enabledSet.has(requested)) {
                throw new Error(`场景未启用: ${requested}`);
            }
            if (!isAllowedByRuntime(requested)) {
                throw new Error(`当前 runtime=${runtime}，不允许场景: ${requested}`);
            }
            return [requested];
        }

        return SCENE_ORDER
            .filter(scene => enabledSet.has(scene))
            .filter(scene => isAllowedByRuntime(scene));
    }

    resolveExtensionPaths(extensionArgs = []) {
        const inputs = asStringArray(extensionArgs, []);
        const uniquePaths = [];
        const seen = new Set();

        for (const item of inputs) {
            const absPath = path.resolve(item);
            if (!fs.existsSync(absPath)) {
                throw new Error(`扩展路径不存在: ${absPath}`);
            }
            const stat = fs.statSync(absPath);
            if (!stat.isDirectory()) {
                throw new Error(`扩展路径必须是目录: ${absPath}`);
            }

            const manifestPath = path.join(absPath, 'manifest.json');
            if (fs.existsSync(manifestPath)) {
                if (!seen.has(absPath)) {
                    seen.add(absPath);
                    uniquePaths.push(absPath);
                }
                continue;
            }

            const children = fs.readdirSync(absPath, { withFileTypes: true })
                .filter(dirent => dirent.isDirectory())
                .map(dirent => path.join(absPath, dirent.name))
                .filter(child => fs.existsSync(path.join(child, 'manifest.json')));

            if (children.length === 0) {
                throw new Error(`目录下未找到扩展(manifest.json): ${absPath}`);
            }

            for (const childPath of children) {
                if (!seen.has(childPath)) {
                    seen.add(childPath);
                    uniquePaths.push(childPath);
                }
            }
        }

        return uniquePaths;
    }

    buildExtensionLaunchArgs(extensionPaths) {
        const joined = extensionPaths.join(',');
        return [
            `--disable-extensions-except=${joined}`,
            `--load-extension=${joined}`
        ];
    }

    sanitizeExtensionMountName(value) {
        const sanitized = String(value || '')
            .trim()
            .replace(/[^A-Za-z0-9._-]/g, '-')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '');
        return sanitized || 'ext';
    }

    buildContainerExtensionMounts(extensionPaths = []) {
        const hostPaths = asStringArray(extensionPaths, []);
        const containerPaths = [];
        const volumeMounts = [];

        hostPaths.forEach((hostPath, idx) => {
            const safeName = this.sanitizeExtensionMountName(path.basename(hostPath));
            const containerPath = path.posix.join(CONTAINER_EXTENSION_ROOT, `ext-${idx + 1}-${safeName}`);
            containerPaths.push(containerPath);
            volumeMounts.push(`${hostPath}:${containerPath}:ro`);
        });

        return { containerPaths, volumeMounts };
    }

    buildSceneConfig(sceneName, options = {}) {
        const def = SCENE_DEFS[sceneName];
        const port = this.scenePort(sceneName);
        const extensionPaths = asStringArray(options.extensionPaths, []);
        const launchOptions = {
            channel: 'chromium',
            headless: def.headless
        };

        if (extensionPaths.length > 0) {
            launchOptions.args = this.buildExtensionLaunchArgs(extensionPaths);
        }

        return {
            server: {
                host: def.listenHost,
                port,
                allowedHosts: [
                    `localhost:${port}`,
                    `127.0.0.1:${port}`,
                    `host.docker.internal:${port}`,
                    `host.containers.internal:${port}`
                ]
            },
            browser: {
                chromiumSandbox: true,
                browserName: 'chromium',
                launchOptions,
                contextOptions: {
                    userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144.0.0.0 Safari/537.36'
                }
            }
        };
    }

    ensureSceneConfig(sceneName, options = {}) {
        fs.mkdirSync(this.config.configDir, { recursive: true });
        const payload = this.buildSceneConfig(sceneName, options);
        const filePath = this.sceneConfigPath(sceneName);
        fs.writeFileSync(filePath, `${JSON.stringify(payload, null, 4)}\n`, 'utf8');
        return filePath;
    }

    async portReady(port) {
        return await new Promise((resolve) => {
            let settled = false;
            const socket = net.createConnection({ host: '127.0.0.1', port });

            const finish = (value) => {
                if (settled) {
                    return;
                }
                settled = true;
                socket.destroy();
                resolve(value);
            };

            socket.setTimeout(300);
            socket.once('connect', () => finish(true));
            socket.once('timeout', () => finish(false));
            socket.once('error', () => finish(false));
        });
    }

    async waitForPort(port) {
        for (let i = 0; i < 30; i += 1) {
            // eslint-disable-next-line no-await-in-loop
            if (await this.portReady(port)) {
                return true;
            }
            // eslint-disable-next-line no-await-in-loop
            await sleep(500);
        }
        return false;
    }

    containerEnv(sceneName, cfgPath, options = {}) {
        const def = SCENE_DEFS[sceneName];
        const requireVncPassword = options.requireVncPassword === true;
        const env = {
            ...process.env,
            PLAYWRIGHT_MCP_DOCKER_TAG: this.config.dockerTag,
            PLAYWRIGHT_MCP_PORT: String(this.scenePort(sceneName)),
            PLAYWRIGHT_MCP_CONFIG_PATH: cfgPath,
            PLAYWRIGHT_MCP_CONTAINER_NAME: def.containerName,
            PLAYWRIGHT_MCP_IMAGE: this.config.headedImage,
            PLAYWRIGHT_MCP_NOVNC_PORT: String(this.config.ports.contHeadedNoVnc)
        };

        if (sceneName === 'cont-headed') {
            const envKey = this.config.vncPasswordEnvKey;
            const password = process.env[envKey];
            if (!password && requireVncPassword) {
                throw new Error(`${envKey} is required for cont-headed`);
            }
            // podman-compose resolves ${VNC_PASSWORD:?..} even for `down`.
            // Keep `up` strict, but use a non-empty placeholder for non-up actions.
            env.VNC_PASSWORD = password || '__MANYOYO_PLACEHOLDER__';
        }

        return env;
    }

    containerComposePath(sceneName) {
        const def = SCENE_DEFS[sceneName];
        return path.join(this.config.composeDir, def.composeFile);
    }

    sceneComposeOverridePath(sceneName) {
        return path.join(this.config.runDir, `${sceneName}.compose.override.yaml`);
    }

    ensureContainerComposeOverride(sceneName, volumeMounts = []) {
        const overridePath = this.sceneComposeOverridePath(sceneName);
        if (!Array.isArray(volumeMounts) || volumeMounts.length === 0) {
            fs.rmSync(overridePath, { force: true });
            return '';
        }

        fs.mkdirSync(this.config.runDir, { recursive: true });
        const lines = [
            'services:',
            '  playwright:',
            '    volumes:'
        ];
        volumeMounts.forEach(item => {
            lines.push(`      - ${JSON.stringify(String(item))}`);
        });
        fs.writeFileSync(overridePath, `${lines.join('\n')}\n`, 'utf8');
        return overridePath;
    }

    async startContainer(sceneName, options = {}) {
        const runtime = this.config.containerRuntime;
        if (!this.ensureCommandAvailable(runtime)) {
            this.writeStderr(`[up] ${sceneName} failed: ${runtime} command not found.`);
            return 1;
        }

        const incomingExtensionPaths = asStringArray(options.extensionPaths, []);
        let configOptions = { ...options, extensionPaths: incomingExtensionPaths };
        const composeFiles = [this.containerComposePath(sceneName)];

        if (incomingExtensionPaths.length > 0) {
            const mapped = this.buildContainerExtensionMounts(incomingExtensionPaths);
            const overridePath = this.ensureContainerComposeOverride(sceneName, mapped.volumeMounts);
            if (overridePath) {
                composeFiles.push(overridePath);
            }
            configOptions = { ...options, extensionPaths: mapped.containerPaths };
        } else {
            this.ensureContainerComposeOverride(sceneName, []);
        }

        const cfgPath = this.ensureSceneConfig(sceneName, configOptions);
        const env = this.containerEnv(sceneName, cfgPath, { requireVncPassword: true });
        const def = SCENE_DEFS[sceneName];

        try {
            const args = [
                runtime,
                'compose',
                '-p',
                def.projectName
            ];
            composeFiles.forEach(filePath => {
                args.push('-f', filePath);
            });
            args.push('up', '-d');
            this.runCmd(args, { env, check: true });
        } catch (error) {
            return error.returncode || 1;
        }

        const port = this.scenePort(sceneName);
        if (await this.waitForPort(port)) {
            this.writeStdout(`[up] ${sceneName} ready on 127.0.0.1:${port}`);
            return 0;
        }

        this.writeStderr(`[up] ${sceneName} did not become ready on 127.0.0.1:${port}`);
        return 1;
    }

    stopContainer(sceneName) {
        const runtime = this.config.containerRuntime;
        if (!this.ensureCommandAvailable(runtime)) {
            this.writeStderr(`[down] ${sceneName} failed: ${runtime} command not found.`);
            return 1;
        }

        this.ensureContainerComposeOverride(sceneName, []);
        const cfgPath = this.sceneConfigPath(sceneName);
        const env = this.containerEnv(sceneName, cfgPath);
        const def = SCENE_DEFS[sceneName];

        try {
            this.runCmd([
                runtime,
                'compose',
                '-p',
                def.projectName,
                '-f',
                this.containerComposePath(sceneName),
                'down'
            ], { env, check: true });
        } catch (error) {
            return error.returncode || 1;
        }

        this.writeStdout(`[down] ${sceneName}`);
        return 0;
    }

    statusContainer(sceneName) {
        const runtime = this.config.containerRuntime;
        if (!this.ensureCommandAvailable(runtime)) {
            this.writeStderr(`[status] ${sceneName} failed: ${runtime} command not found.`);
            return 1;
        }

        const def = SCENE_DEFS[sceneName];
        const cp = this.runCmd([
            runtime,
            'ps',
            '--filter',
            `name=${def.containerName}`,
            '--format',
            '{{.Names}}'
        ], { captureOutput: true, check: false });

        const names = new Set(
            cp.stdout
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(Boolean)
        );

        if (names.has(def.containerName)) {
            this.writeStdout(`[status] ${sceneName} running`);
        } else {
            this.writeStdout(`[status] ${sceneName} stopped`);
        }
        return 0;
    }

    logsContainer(sceneName) {
        const runtime = this.config.containerRuntime;
        if (!this.ensureCommandAvailable(runtime)) {
            this.writeStderr(`[logs] ${sceneName} failed: ${runtime} command not found.`);
            return 1;
        }

        const def = SCENE_DEFS[sceneName];
        const cp = this.runCmd([
            runtime,
            'logs',
            '--tail',
            '80',
            def.containerName
        ], { captureOutput: true, check: false });

        const output = cp.stdout || cp.stderr;
        if (output.trim()) {
            this.writeStdout(output.trimEnd());
        } else {
            this.writeStdout(`[logs] ${sceneName} no logs`);
        }

        return cp.returncode === 0 ? 0 : 1;
    }

    spawnHostProcess(cfgPath, logFd) {
        return spawn('npx', [`@playwright/mcp@${this.config.npmVersion}`, '--config', String(cfgPath)], {
            detached: true,
            stdio: ['ignore', logFd, logFd]
        });
    }

    stopHostStarter(pid) {
        if (!Number.isInteger(pid) || pid <= 0) {
            return;
        }
        try {
            process.kill(-pid, 'SIGTERM');
            return;
        } catch {
            // no-op
        }
        try {
            process.kill(pid, 'SIGTERM');
        } catch {
            // no-op
        }
    }

    hostScenePids(sceneName) {
        const cfgPath = this.sceneConfigPath(sceneName);
        const pattern = `playwright-mcp.*--config ${cfgPath}`;
        const cp = this.runCmd(['pgrep', '-f', pattern], { captureOutput: true, check: false });

        if (cp.returncode !== 0 || !cp.stdout.trim()) {
            return [];
        }

        const pids = [];
        for (const line of cp.stdout.split(/\r?\n/)) {
            const text = line.trim();
            if (/^\d+$/.test(text)) {
                pids.push(Number(text));
            }
        }
        return pids;
    }

    async waitForHostPids(sceneName, fallbackPid) {
        for (let i = 0; i < 5; i += 1) {
            const pids = this.hostScenePids(sceneName);
            if (pids.length > 0) {
                return pids;
            }
            // eslint-disable-next-line no-await-in-loop
            await sleep(100);
        }
        if (Number.isInteger(fallbackPid) && fallbackPid > 0) {
            return [fallbackPid];
        }
        return [];
    }

    async startHost(sceneName, options = {}) {
        if (!this.ensureCommandAvailable('npx')) {
            this.writeStderr(`[up] ${sceneName} failed: npx command not found.`);
            return 1;
        }

        fs.mkdirSync(this.config.runDir, { recursive: true });
        const cfgPath = this.ensureSceneConfig(sceneName, options);
        const pidFile = this.scenePidFile(sceneName);
        const logFile = this.sceneLogFile(sceneName);
        const port = this.scenePort(sceneName);

        let managedPids = this.hostScenePids(sceneName);
        if (managedPids.length > 0 && (await this.portReady(port))) {
            this.writeStdout(`[up] ${sceneName} already running (pid(s) ${managedPids.join(' ')})`);
            return 0;
        }

        if (await this.portReady(port)) {
            this.writeStderr(`[up] ${sceneName} failed: port ${port} is already in use by another process.`);
            this.writeStderr('Stop the conflicting process first, then retry.');
            return 1;
        }

        fs.rmSync(pidFile, { force: true });
        const logFd = fs.openSync(logFile, 'a');
        const starter = this.spawnHostProcess(cfgPath, logFd);
        fs.closeSync(logFd);
        if (typeof starter.unref === 'function') {
            starter.unref();
        }

        if (await this.waitForPort(port)) {
            managedPids = await this.waitForHostPids(sceneName, starter.pid);
            if (managedPids.length > 0) {
                fs.writeFileSync(pidFile, `${managedPids[0]}`, 'utf8');
                this.writeStdout(`[up] ${sceneName} ready on 127.0.0.1:${port} (pid(s) ${managedPids.join(' ')})`);
                return 0;
            }
        }

        this.writeStderr(`[up] ${sceneName} failed to start. tail ${logFile}:`);
        const tail = tailText(logFile, 30);
        if (tail) {
            this.writeStderr(tail);
        }

        if (starter.exitCode === null && !starter.killed) {
            this.stopHostStarter(starter.pid);
        }

        return 1;
    }

    async stopHost(sceneName) {
        const pidFile = this.scenePidFile(sceneName);
        const port = this.scenePort(sceneName);
        const managedPids = this.hostScenePids(sceneName);

        for (const pid of managedPids) {
            try {
                process.kill(pid, 'SIGTERM');
            } catch {
                // no-op
            }
        }

        if (managedPids.length > 0) {
            await sleep(300);
        }

        if (fs.existsSync(pidFile)) {
            const text = fs.readFileSync(pidFile, 'utf8').trim();
            if (/^\d+$/.test(text)) {
                try {
                    process.kill(Number(text), 'SIGTERM');
                } catch {
                    // no-op
                }
            }
            fs.rmSync(pidFile, { force: true });
        }

        if (await this.portReady(port)) {
            this.writeStderr(`[down] ${sceneName} warning: port ${port} is still in use (possibly unmanaged process)`);
            return 1;
        }

        this.writeStdout(`[down] ${sceneName}`);
        return 0;
    }

    async statusHost(sceneName) {
        const pidFile = this.scenePidFile(sceneName);
        const port = this.scenePort(sceneName);
        const managedPids = this.hostScenePids(sceneName);

        if (managedPids.length > 0 && (await this.portReady(port))) {
            this.writeStdout(`[status] ${sceneName} running (pid(s) ${managedPids.join(' ')})`);
            const pidfileValid = fs.existsSync(pidFile) && /^\d+$/.test(fs.readFileSync(pidFile, 'utf8').trim());
            if (!pidfileValid) {
                fs.mkdirSync(path.dirname(pidFile), { recursive: true });
                fs.writeFileSync(pidFile, `${managedPids[0]}`, 'utf8');
            }
            return 0;
        }

        if (managedPids.length > 0 && !(await this.portReady(port))) {
            this.writeStdout(`[status] ${sceneName} degraded (pid(s) ${managedPids.join(' ')}, port ${port} not reachable)`);
            return 0;
        }

        fs.rmSync(pidFile, { force: true });
        if (await this.portReady(port)) {
            this.writeStdout(`[status] ${sceneName} conflict (port ${port} in use by unmanaged process)`);
        } else {
            this.writeStdout(`[status] ${sceneName} stopped`);
        }
        return 0;
    }

    async healthScene(sceneName) {
        const port = this.scenePort(sceneName);
        if (await this.portReady(port)) {
            this.writeStdout(`[health] ${sceneName} ok (127.0.0.1:${port})`);
            return 0;
        }
        this.writeStdout(`[health] ${sceneName} fail (127.0.0.1:${port})`);
        return 1;
    }

    logsHost(sceneName) {
        const logFile = this.sceneLogFile(sceneName);
        if (!fs.existsSync(logFile)) {
            this.writeStdout(`[logs] ${sceneName} no log file: ${logFile}`);
            return 0;
        }

        const tail = tailText(logFile, 80);
        if (tail) {
            this.writeStdout(tail);
        }
        return 0;
    }

    async downloadFile(url, output, retries = 3, timeoutMs = 60_000) {
        const timeoutSec = Math.max(1, Math.ceil(timeoutMs / 1000));
        if (!this.ensureCommandAvailable('curl')) {
            throw new Error('curl command not found');
        }

        let lastError = null;
        for (let i = 1; i <= retries; i += 1) {
            try {
                const result = this.runCmd([
                    'curl',
                    '--fail',
                    '--location',
                    '--silent',
                    '--show-error',
                    '--connect-timeout',
                    String(timeoutSec),
                    '--max-time',
                    String(timeoutSec),
                    '--output',
                    output,
                    url
                ], { captureOutput: true, check: false });
                if (result.returncode !== 0) {
                    throw new Error(result.stderr || `curl failed with exit code ${result.returncode}`);
                }
                return;
            } catch (error) {
                lastError = error;
                if (i < retries) {
                    // eslint-disable-next-line no-await-in-loop
                    await sleep(1000);
                }
            }
        }

        throw new Error(`download failed after ${retries} attempts: ${url}; ${String(lastError)}`);
    }

    extractZipBuffer(zipBuffer, outDir) {
        fs.mkdirSync(outDir, { recursive: true });
        const tempZip = path.join(os.tmpdir(), `manyoyo-playwright-ext-${process.pid}-${Date.now()}.zip`);
        fs.writeFileSync(tempZip, zipBuffer);

        const result = spawnSync('unzip', ['-oq', tempZip, '-d', outDir], { encoding: 'utf8' });
        fs.rmSync(tempZip, { force: true });

        if (result.error) {
            throw result.error;
        }
        if (result.status !== 0) {
            throw new Error(result.stderr || `unzip failed with exit code ${result.status}`);
        }
    }

    extractCrx(crxFile, outDir) {
        const data = fs.readFileSync(crxFile);
        const offset = crxZipOffset(data);
        const zipBuffer = data.subarray(offset);

        this.extractZipBuffer(zipBuffer, outDir);

        const manifest = path.join(outDir, 'manifest.json');
        if (!fs.existsSync(manifest)) {
            throw new Error(`${crxFile} extracted but manifest.json missing`);
        }

        if (convertManifestV2ToV3(outDir)) {
            this.writeStdout(`[manifest] upgraded to MV3: ${path.basename(outDir)}`);
        }
    }

    async downloadExtensions(options = {}) {
        if (!this.ensureCommandAvailable('unzip')) {
            this.writeStderr('[ext-download] failed: unzip command not found.');
            return 1;
        }

        const prodversion = String(options.prodversion || this.config.extensionProdversion || '132.0.0.0').trim();
        const extDir = path.resolve(this.extensionDirPath());
        const tmpDir = path.resolve(this.extensionTmpDirPath());

        fs.rmSync(tmpDir, { recursive: true, force: true });
        fs.mkdirSync(extDir, { recursive: true });
        fs.mkdirSync(tmpDir, { recursive: true });

        try {
            this.writeStdout(`[info] ext dir: ${extDir}`);
            this.writeStdout(`[info] tmp dir: ${tmpDir}`);

            for (const [name, extId] of EXTENSIONS) {
                const url = buildCrxUrl(extId, prodversion);
                const crxFile = path.join(tmpDir, `${name}.crx`);
                const outDir = path.join(extDir, name);

                this.writeStdout(`[download] ${name}`);
                // eslint-disable-next-line no-await-in-loop
                await this.downloadFile(url, crxFile);

                this.writeStdout(`[extract] ${name}`);
                fs.rmSync(outDir, { recursive: true, force: true });
                this.extractCrx(crxFile, outDir);
            }
        } finally {
            fs.rmSync(tmpDir, { recursive: true, force: true });
            this.writeStdout(`[cleanup] removed ${tmpDir}`);
        }

        this.writeStdout(`[done] all extensions are ready: ${extDir}`);
        return 0;
    }

    detectCurrentIPv4() {
        const interfaces = os.networkInterfaces();
        for (const values of Object.values(interfaces)) {
            if (!Array.isArray(values)) {
                continue;
            }
            for (const item of values) {
                if (!item || item.internal) {
                    continue;
                }
                if (item.family === 'IPv4') {
                    return item.address;
                }
            }
        }
        return '';
    }

    resolveMcpAddHost(hostArg) {
        if (!hostArg) {
            return this.config.mcpDefaultHost;
        }
        const value = String(hostArg).trim();
        if (!value) {
            return '';
        }
        if (value === 'current-ip') {
            return this.detectCurrentIPv4();
        }
        return value;
    }

    printMcpAdd(hostArg) {
        const host = this.resolveMcpAddHost(hostArg);
        if (!host) {
            this.writeStderr('[mcp-add] failed: cannot determine host. Use --host <host> to set one explicitly.');
            return 1;
        }

        const scenes = this.resolveTargets('all');
        for (const sceneName of scenes) {
            const url = `http://${host}:${this.scenePort(sceneName)}/mcp`;
            this.writeStdout(`claude mcp add --transport http playwright-${sceneName} ${url}`);
        }
        this.writeStdout('');
        for (const sceneName of scenes) {
            const url = `http://${host}:${this.scenePort(sceneName)}/mcp`;
            this.writeStdout(`codex mcp add playwright-${sceneName} --url ${url}`);
        }

        return 0;
    }

    printSummary() {
        const scenes = this.resolveTargets('all');
        this.writeStdout(`playwright\truntime=${this.config.runtime}\tscenes=${scenes.join(',')}`);
        return 0;
    }

    async runOnScene(action, sceneName, options = {}) {
        const def = SCENE_DEFS[sceneName];
        if (action === 'up') {
            return def.type === 'container'
                ? await this.startContainer(sceneName, options)
                : await this.startHost(sceneName, options);
        }
        if (action === 'down') {
            return def.type === 'container'
                ? this.stopContainer(sceneName)
                : await this.stopHost(sceneName);
        }
        if (action === 'status') {
            return def.type === 'container'
                ? this.statusContainer(sceneName)
                : await this.statusHost(sceneName);
        }
        if (action === 'health') {
            return await this.healthScene(sceneName);
        }
        if (action === 'logs') {
            return def.type === 'container'
                ? this.logsContainer(sceneName)
                : this.logsHost(sceneName);
        }
        this.writeStderr(`unknown action: ${action}`);
        return 1;
    }

    async run({ action, scene = 'host-headless', host = '', extensions = [], prodversion = '' }) {
        if (action === 'ls') {
            return this.printSummary();
        }

        if (action === 'mcp-add') {
            return this.printMcpAdd(host);
        }

        if (action === 'ext-download') {
            return await this.downloadExtensions({ prodversion });
        }

        if (!VALID_ACTIONS.has(action)) {
            throw new Error(`未知 plugin 动作: ${action}`);
        }

        const targets = this.resolveTargets(scene);
        if (targets.length === 0) {
            this.writeStderr('没有可执行场景，请检查 runtime 与 enabledScenes 配置');
            return 1;
        }

        const extensionPaths = action === 'up'
            ? this.resolveExtensionPaths(extensions)
            : [];

        let rc = 0;
        for (const sceneName of targets) {
            // eslint-disable-next-line no-await-in-loop
            const code = await this.runOnScene(action, sceneName, { extensionPaths });
            if (code !== 0) {
                rc = 1;
            }
        }

        return rc;
    }
}

module.exports = {
    EXTENSIONS,
    SCENE_ORDER,
    SCENE_DEFS,
    PlaywrightPlugin
};
